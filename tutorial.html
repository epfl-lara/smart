
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Tutorial: Sorting &#8212; Stainless 3.0 documentation</title>
    <link rel="stylesheet" href="_static/css/stainless.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Pure Scala" href="purescala.html" />
    <link rel="prev" title="Installing Stainless" href="installation.html" /> 
  </head><body>
    <div class="header-wrapper">
      <div class="header">
        <div class="left">
            <div class="headertitle"><a
              href="index.html">Stainless Documentation</a></div>
            <div class="rel">
              <a href="installation.html">Installing Stainless</a> |
              <a class="uplink" href="index.html">Contents</a>
              | <a href="purescala.html">Pure Scala</a>
            </div>
        </div>
        <div class="right">
          <form class="search" action="search.html" method="get">
            <input type="text" name="q" placeholder="Search.." />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
        </div>
        <div class="clearer"></div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial-sorting">
<span id="tutorial"></span><h1>Tutorial: Sorting<a class="headerlink" href="#tutorial-sorting" title="Permalink to this headline">¶</a></h1>
<p>This tutorial shows how to:</p>
<blockquote>
<div><ul class="simple">
<li>use <cite>ensuring</cite>, <cite>require</cite>, and <cite>holds</cite> constructs</li>
<li>learn the difference between <cite>Int</cite> and <cite>BigInt</cite></li>
<li>define lists as algebraic data types</li>
<li>use sets and recursive function to specify data structures</li>
</ul>
</div></blockquote>
<p>See <a class="reference internal" href="gettingstarted.html"><span class="doc">Getting Started</span></a> about how to setup the command line
tool.</p>
<div class="section" id="warm-up-max">
<h2>Warm-up: Max<a class="headerlink" href="#warm-up-max" title="Permalink to this headline">¶</a></h2>
<p>As a warm-up illustrating verification, we define and debug a <cite>max</cite> function
and specify its properties. Stainless uses Scala constructs
<cite>require</cite> and <cite>ensuring</cite> to document preconditions and
postconditions of functions. Note that, in addition to
checking these conditions at run-time (which standard Scala
does), Stainless can analyze the specifications statically and
prove them for <em>all</em> executions, or, if they are wrong, automatically find
inputs for which the conditions fail.</p>
<p>Consider the following definition inside of an object <cite>TestMax</cite>.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">TestMax</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
    <span class="k">else</span> <span class="n">y</span>
  <span class="o">}</span> <span class="n">ensuring</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">x</span> <span class="o">||</span> <span class="n">res</span> <span class="o">==</span> <span class="n">y</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
<p>A Stainless program consists of one or more modules delimited by
<cite>object</cite> and <cite>class</cite> declarations.
The code of <cite>max</cite> attempts to compute the maximum of two given arguments
by subtracting them. If the result is positive, it returns
the first one, otherwise, it returns the second one.</p>
<p>To specify the correctness of the computed result, we use
the <cite>ensuring</cite> clause.  In this case, the clause specifies
that the result is larger than <cite>x</cite> and than <cite>y</cite>, and that it
equals to one of them. The construct <cite>ensuring(res =&gt; P)</cite>
denotes that, if we denote by <cite>res</cite> the return value of the
function, then <cite>res</cite> satisfies the boolean-valued expression
<cite>P</cite>.  The name <cite>res</cite> we chose is an arbitrary bound variable
(even though we often tend to use <cite>res</cite>).</p>
<p>We can evaluate this code on some values by writing
parameterless functions and inspecting what they evaluate
to. The web interface will display these results for us.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">test1</span> <span class="k">=</span> <span class="n">max</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="k">def</span> <span class="n">test2</span> <span class="k">=</span> <span class="n">max</span><span class="o">(-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="k">def</span> <span class="n">test3</span> <span class="k">=</span> <span class="n">max</span><span class="o">(-</span><span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">)</span>
</pre></div>
</div>
<p>The code seems to work correctly on the example values.
However, Stainless automatically finds that it is not correct,
showing us a counter-example inputs, such as</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1639624704</span>
<span class="n">y</span> <span class="o">-&gt;</span> <span class="mi">1879048192</span>
</pre></div>
</div>
<p>We may wish to define a test method</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">test4</span> <span class="k">=</span> <span class="n">max</span><span class="o">(-</span><span class="mi">1639624704</span><span class="o">,</span> <span class="mi">1879048192</span><span class="o">)</span>
</pre></div>
</div>
<p>whose evaluation indeed results in <cite>ensuring</cite> condition being violated.
The problem is due to overflow of 32-bit integers, due to which
the value <cite>d</cite> becomes positive, even though <cite>x</cite> is negative and thus smaller than
the large positive value <cite>y</cite>.
As in Scala, the <cite>Int</cite> type denotes 32-bit
integers with the usual signed arithmetic operations from
computer architecture and the JVM specification.</p>
<p>To use unbounded integers, we simply change the types to
<cite>BigInt</cite>, obtaining a program that verifies (and, as
expected, passes all the test cases).</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
  <span class="k">else</span> <span class="n">y</span>
<span class="o">}</span> <span class="n">ensuring</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span>
  <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">x</span> <span class="o">||</span> <span class="n">res</span> <span class="o">==</span> <span class="n">y</span><span class="o">))</span>
</pre></div>
</div>
<p>As a possibly simpler specification, we could have also
defined the reference implementation</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">rmax</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">y</span> <span class="k">else</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div>
</div>
<p>and then used as the postcondition of <cite>max</cite> simply</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">ensuring</span> <span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span>  <span class="n">res</span> <span class="o">==</span> <span class="n">rmax</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">))</span>
</pre></div>
</div>
<p>In general, Stainless uses both function body and function
specification when reasoning about the function and its
uses. Thus, we need not repeat in the postcondition those
aspects of function body that follow directly through
inlining the function, but we may wish to state those
that require induction to prove.</p>
<p>The fact that we can use functions in preconditions
and postconditions allows us to state fairly general
properties. For example, the following lemma verifies
a number of algebraic properties of <cite>max</cite>.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">max_lemma</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span>
  <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="n">max</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">max</span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">z</span><span class="o">))</span> <span class="o">==</span> <span class="n">max</span><span class="o">(</span><span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
  <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">+</span> <span class="n">z</span> <span class="o">==</span> <span class="n">max</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="o">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">)</span>
<span class="o">}</span> <span class="n">holds</span>
</pre></div>
</div>
<p>Here <cite>holds</cite> operator on the function body is an
abbreviation for the postcondition stating that the returned
result is always true, that is, for</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">ensuring</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span><span class="o">==</span><span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
<p>As a guideline, we typically use <cite>holds</cite> to express such
algebraic properties that relate multiple invocations of
functions, whereas we use <cite>ensuring</cite> to document property of
an arbitrary single invocation of a function. Stainless is more likely to automatically
use the property of a function if it is associated with it using
<cite>ensuring</cite> than using an external lemma.</p>
<p>Going back to our buggy implementation of <cite>max</cite> on <cite>Int</cite>-s,
an alternative to using <cite>BigInt</cite>-s is to decide that
the method should only be used under certain conditions,
such as <cite>x</cite> and <cite>y</cite> being non-negative. To specify the
conditions on input, we use the <cite>require</cite> clause.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span>
  <span class="k">else</span> <span class="n">y</span>
<span class="o">}</span> <span class="n">ensuring</span> <span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span>
  <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">x</span> <span class="o">||</span> <span class="n">res</span> <span class="o">==</span> <span class="n">y</span><span class="o">))</span>
</pre></div>
</div>
<p>This program verifies and indeed works correctly on
non-negative 32-bit integers as inputs.</p>
<p><strong>Question:</strong> What if we restrict the inputs to <cite>max</cite> to be
<cite>a)</cite> non-positive, or <cite>b)</cite> strictly negative? Modify the
<cite>require</cite> clause for each case accordingly and explain the
behavior of Stainless.</p>
<p>In the sequel, we will mostly use <cite>BigInt</cite> types.</p>
</div>
<div class="section" id="defining-lists-and-their-properties">
<h2>Defining Lists and Their Properties<a class="headerlink" href="#defining-lists-and-their-properties" title="Permalink to this headline">¶</a></h2>
<p>We next consider sorting an unbounded number of elements.
For this purpose, we define a data structure for lists of
integers.  Stainless has a built-in data type of parametric
lists, see <a class="reference internal" href="library.html"><span class="doc">Stainless Library</span></a>, but here we define
our own variant instead.</p>
<div class="section" id="lists">
<h3>Lists<a class="headerlink" href="#lists" title="Permalink to this headline">¶</a></h3>
<p>We use a recursive algebraic data type
definition, expressed using Scala’s <strong>case classes</strong>.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">head</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">List</span>
</pre></div>
</div>
<p>We can read the definition as follows: the set of lists is
defined as the least set that satisfies them:</p>
<blockquote>
<div><ul class="simple">
<li>empty list <cite>Nil</cite> is a list</li>
<li>if <cite>head</cite> is an integer and <cite>tail</cite> is a <cite>List</cite>, then
<cite>Cons(head,tail)</cite> is a <cite>List</cite>.</li>
</ul>
</div></blockquote>
<p>Each list is constructed by applying the above two rules
finitely many times.  A concrete list containing elements 5,
2, and 7, in that order, is denoted</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">Cons</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
</pre></div>
</div>
<p>Having defined the structure of lists, we can move on to
define some semantic properties of lists that are of
interests. For this purpose, we use recursive functions
defined on lists.</p>
</div>
<div class="section" id="size-of-a-list">
<h3>Size of a List<a class="headerlink" href="#size-of-a-list" title="Permalink to this headline">¶</a></h3>
<p>As the starting point, we define the size of a list.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">)</span> <span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>
<span class="o">})</span>
</pre></div>
</div>
<p>The definition uses <em>pattern matching</em> to define size of the
list in the case it is empty (where it is zero) and when it
is non-empty, or, if it’s non-empty, then it has a head <cite>x</cite>
and the rest of the list <cite>rest</cite>, so the size is one plus the
size of the rest. Thus <cite>size</cite> is a recursive function.  A
strength of Stainless is that it allows using such recursive
functions in specifications.</p>
<p>It makes little sense to try to write a complete
specification of <cite>size</cite>, given that its recursive definition
is already a pretty clear description of its
meaning. However, it is useful to add a consequence of this
definition, namely that the size is non-negative. The reason
is that Stainless most of the time reasons by unfolding <cite>size</cite>,
and the property of size being non-negative is not revealed
by such unfolding. Once specified, the non-negativity is
easily proven and Stainless will make use of it.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">)</span> <span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span> <span class="o">(</span><span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">BigInt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>
<span class="o">})</span> <span class="n">ensuring</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="sorted-lists">
<h3>Sorted Lists<a class="headerlink" href="#sorted-lists" title="Permalink to this headline">¶</a></h3>
<p>We define properties of values simply as executable
predicates that check if the property holds. The following
is a property that a list is sorted in a strictly ascending
order.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isSorted</span><span class="o">(</span><span class="n">l</span> <span class="k">:</span> <span class="kt">List</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span><span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x2</span><span class="o">,</span> <span class="n">rest</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span> <span class="o">&amp;&amp;</span> <span class="n">isSorted</span><span class="o">(</span><span class="nc">Cons</span><span class="o">(</span><span class="n">x2</span><span class="o">,</span><span class="n">rest</span><span class="o">))</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="insertion-into-sorted-list">
<h2>Insertion into Sorted List<a class="headerlink" href="#insertion-into-sorted-list" title="Permalink to this headline">¶</a></h2>
<p>Consider the following specification of insertion into a sorted list. It’s a
building block for an insertion sort.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">sInsert</span><span class="o">(</span><span class="n">x</span> <span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">l</span> <span class="k">:</span> <span class="kt">List</span><span class="o">)</span> <span class="k">:</span> <span class="kt">List</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">isSorted</span><span class="o">(</span><span class="n">l</span><span class="o">))</span>
  <span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="n">rest</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">sInsert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">rest</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="n">ensuring</span> <span class="o">{(</span><span class="n">res</span><span class="k">:</span><span class="kt">List</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">isSorted</span><span class="o">(</span><span class="n">res</span><span class="o">)}</span>
</pre></div>
</div>
<p>Stainless verifies that the returned list is indeed sorted. Note
how we are again using a recursively defined function to
specify another function. We can introduce a bug into the
definition above and examine the counterexamples that Stainless
finds.</p>
</div>
<div class="section" id="being-sorted-is-not-enough">
<h2>Being Sorted is Not Enough<a class="headerlink" href="#being-sorted-is-not-enough" title="Permalink to this headline">¶</a></h2>
<p>Note, however, that a function such as this one is also correct.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fsInsert</span><span class="o">(</span><span class="n">x</span> <span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">l</span> <span class="k">:</span> <span class="kt">List</span><span class="o">)</span> <span class="k">:</span> <span class="kt">List</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">isSorted</span><span class="o">(</span><span class="n">l</span><span class="o">))</span>
  <span class="nc">Nil</span>
<span class="o">}</span> <span class="n">ensuring</span> <span class="o">{(</span><span class="n">res</span><span class="k">:</span><span class="kt">List</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">isSorted</span><span class="o">(</span><span class="n">res</span><span class="o">)}</span>
</pre></div>
</div>
<p>So, our specification may be considered weak, because it does
not say anything about the elements.</p>
</div>
<div class="section" id="using-size-in-specification">
<h2>Using Size in Specification<a class="headerlink" href="#using-size-in-specification" title="Permalink to this headline">¶</a></h2>
<p>Consider a stronger additional postcondition property:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">size</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o">==</span> <span class="n">size</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Does it hold? If we try to add it, we obtain a counterexample.
A correct strengthening, taking into account that the element
may or may not already be in the list, is the following.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">size</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="using-content-in-specification">
<h2>Using Content in Specification<a class="headerlink" href="#using-content-in-specification" title="Permalink to this headline">¶</a></h2>
<p>A stronger specification needs to talk about the <cite>content</cite>
of the list.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">sInsert</span><span class="o">(</span><span class="n">x</span> <span class="k">:</span> <span class="kt">BigInt</span><span class="o">,</span> <span class="n">l</span> <span class="k">:</span> <span class="kt">List</span><span class="o">)</span> <span class="k">:</span> <span class="kt">List</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">isSorted</span><span class="o">(</span><span class="n">l</span><span class="o">))</span>
  <span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="n">rest</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">sInsert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">rest</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="n">ensuring</span> <span class="o">{(</span><span class="n">res</span><span class="k">:</span><span class="kt">List</span><span class="o">)</span> <span class="k">=&gt;</span>
   <span class="n">isSorted</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">content</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o">==</span> <span class="n">content</span><span class="o">(</span><span class="n">l</span><span class="o">)</span> <span class="o">++</span> <span class="nc">Set</span><span class="o">(</span><span class="n">x</span><span class="o">)}</span>
</pre></div>
</div>
<p>To compute <cite>content</cite>, in this example we use sets (even
though in general, it might be better to use bags
i.e. multisets).</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">content</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">)</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">BigInt</span><span class="o">]</span> <span class="k">=</span> <span class="n">l</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Set</span><span class="o">()</span>
  <span class="k">case</span> <span class="nc">Cons</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">++</span> <span class="n">content</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This completes the tutorial. To learn more, check the rest of this
documentation and browse the examples provided with Stainless.</p>
</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installing Stainless</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial: Sorting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#warm-up-max">Warm-up: Max</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-lists-and-their-properties">Defining Lists and Their Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="#insertion-into-sorted-list">Insertion into Sorted List</a></li>
<li class="toctree-l2"><a class="reference internal" href="#being-sorted-is-not-enough">Being Sorted is Not Enough</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-size-in-specification">Using Size in Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-content-in-specification">Using Content in Specification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="purescala.html">Pure Scala</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">Stainless Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="imperative.html">Imperative</a></li>
<li class="toctree-l1"><a class="reference internal" href="verification.html">Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="neon.html">Proving Theorems</a></li>
<li class="toctree-l1"><a class="reference internal" href="limitations.html">Limitations of Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="options.html">Command Line Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="smartcontracts.html">Stainless Smart Contracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals.html">Stainless’ Internals</a></li>
</ul>

        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
            <a href="_sources/tutorial.rst.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
            &copy; Copyright 2017 (alphabetically) by M. Antognini, R. Blanc, S. Gruetter, L. Hupel, E. Kneuss, M. Koukoutos, V. Kuncak, R. Madhavan, S. Stucki, P. Suter.
          Last updated on Sep 27, 2018.
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>